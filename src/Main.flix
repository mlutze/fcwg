use Options.Command;
use Options.parse;
use Options.usage;
use Transform.visitClass;
use Version.version;

use Wrapped/Class.forNameString;
use Wrapped/Exception.getMessage;

// The main entry point.
def main(): Int32 & Impure =
    use Result.flatMap;
    let args = Environment.getArgs();
    match parse(args) {
        case Success(Command.Go(name, options)) =>
            match {
                let* clazz = forNameString(name);
                visitClass(options, clazz)
            } {
                case Ok(ns) =>
                    println(ns);
                    0
                case Err(err) =>
                    System/StdErr.println(getMessage(err));
                    1
            }
        case Success(Command.GetVersion) =>
            println(version());
            0
        case Success(Command.GetHelp) =>
            print(usage());
            0
        case Success(_) =>
            System/StdErr.println("Unsupported operation.");
            1
        case Failure(errs) =>
            errs |> Nec.foreach(System/StdErr.print);
            System/StdErr.print(usage());
            2
    }
